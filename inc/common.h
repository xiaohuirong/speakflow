// Various helper functions and utilities

#pragma once

#include <ctime>
#include <fstream>
#include <map>
#include <random>
#include <sstream>
#include <string>
#include <thread>
#include <vector>

using namespace std;

//
// GPT CLI argument parsing
//

struct gpt_params {
  int32_t seed = -1; // RNG seed
  int32_t n_threads = min(4, (int32_t)thread::hardware_concurrency());
  int32_t n_predict = 200;  // new tokens to predict
  int32_t n_parallel = 1;   // number of parallel streams
  int32_t n_batch = 32;     // batch size for prompt processing
  int32_t n_ctx = 2048;     // context size (this is the KV cache max size)
  int32_t n_gpu_layers = 0; // number of layers to offlload to the GPU

  bool ignore_eos = false; // ignore EOS token when generating text

  // sampling parameters
  int32_t top_k = 40;
  float top_p = 0.9f;
  float temp = 0.9f;
  int32_t repeat_last_n = 64;
  float repeat_penalty = 1.00f;

  string model = "models/gpt-2-117M/ggml-model.bin"; // model path
  string prompt = "";
  string token_test = "";

  bool interactive = false;
  int32_t interactive_port = -1;
};

auto gpt_params_parse(int argc, char **argv, gpt_params &params) -> bool;

void gpt_print_usage(int argc, char **argv, const gpt_params &params);

auto gpt_random_prompt(mt19937 &rng) -> string;

//
// Vocab utils
//

auto trim(const string &s) -> string;

auto replace(const string &s, const string &from, const string &to) -> string;

struct gpt_vocab {
  using id = int32_t;
  using token = string;

  map<token, id> token_to_id;
  map<id, token> id_to_token;
  vector<string> special_tokens;

  void add_special_token(const string &token);
};

// poor-man's JSON parsing
auto json_parse(const string &fname) -> map<string, int32_t>;

auto convert_to_utf8(const wstring &input) -> string;

auto convert_to_wstring(const string &input) -> wstring;

void gpt_split_words(string str, vector<string> &words);

// split text into tokens
//
// ref:
// https://github.com/openai/gpt-2/blob/a74da5d99abaaba920de8131d64da2862a8f213b/src/encoder.py#L53
//
// Regex (Python):
// r"""'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+|
// ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+"""
//
// Regex (C++):
// R"('s|'t|'re|'ve|'m|'ll|'d| ?[[:alpha:]]+| ?[[:digit:]]+|
// ?[^\s[:alpha:][:digit:]]+|\s+(?!\S)|\s+)"
//
auto gpt_tokenize(const gpt_vocab &vocab, const string &text)
    -> vector<gpt_vocab::id>;

// test outputs of gpt_tokenize
//
//   - compare with tokens generated by the huggingface tokenizer
//   - test cases are chosen based on the model's main language (under 'prompt'
//   directory)
//   - if all sentences are tokenized identically, print 'All tests passed.'
//   - otherwise, print sentence, huggingface tokens, ggml tokens
//
void test_gpt_tokenizer(gpt_vocab &vocab, const string &fpath_test);

// load the tokens from encoder.json
auto gpt_vocab_init(const string &fname, gpt_vocab &vocab) -> bool;

// sample next token given probabilities for each embedding
//
//   - consider only the top K tokens
//   - from them, consider only the top tokens with cumulative probability > P
//
// TODO: not sure if this implementation is correct
// TODO: temperature is not implemented
//
auto gpt_sample_top_k_top_p(const gpt_vocab &vocab, const float *logits,
                            int top_k, double top_p, double temp, mt19937 &rng)
    -> gpt_vocab::id;

auto gpt_sample_top_k_top_p_repeat(const gpt_vocab &vocab, const float *logits,
                                   const int32_t *last_n_tokens_data,
                                   size_t last_n_tokens_data_size, int top_k,
                                   double top_p, double temp, int repeat_last_n,
                                   float repeat_penalty, mt19937 &rng)
    -> gpt_vocab::id;

//
// Audio utils
//

// Write PCM data into WAV audio file
class wav_writer {
private:
  ofstream file;
  uint32_t dataSize = 0;
  string wav_filename;

  auto write_header(const uint32_t sample_rate, const uint16_t bits_per_sample,
                    const uint16_t channels) -> bool {

    file.write("RIFF", 4);
    file.write("\0\0\0\0", 4); // Placeholder for file size
    file.write("WAVE", 4);
    file.write("fmt ", 4);

    const uint32_t sub_chunk_size = 16;
    const uint16_t audio_format = 1; // PCM format
    const uint32_t byte_rate = sample_rate * channels * bits_per_sample / 8;
    const uint16_t block_align = channels * bits_per_sample / 8;

    file.write(reinterpret_cast<const char *>(&sub_chunk_size), 4);
    file.write(reinterpret_cast<const char *>(&audio_format), 2);
    file.write(reinterpret_cast<const char *>(&channels), 2);
    file.write(reinterpret_cast<const char *>(&sample_rate), 4);
    file.write(reinterpret_cast<const char *>(&byte_rate), 4);
    file.write(reinterpret_cast<const char *>(&block_align), 2);
    file.write(reinterpret_cast<const char *>(&bits_per_sample), 2);
    file.write("data", 4);
    file.write("\0\0\0\0", 4); // Placeholder for data size

    return true;
  }

  // It is assumed that PCM data is normalized to a range from -1 to 1
  auto write_audio(const float *data, size_t length) -> bool {
    for (size_t i = 0; i < length; ++i) {
      const auto intSample = int16_t(data[i] * 32767);
      file.write(reinterpret_cast<const char *>(&intSample), sizeof(int16_t));
      dataSize += sizeof(int16_t);
    }
    if (file.is_open()) {
      file.seekp(4, ios::beg);
      uint32_t fileSize = 36 + dataSize;
      file.write(reinterpret_cast<char *>(&fileSize), 4);
      file.seekp(40, ios::beg);
      file.write(reinterpret_cast<char *>(&dataSize), 4);
      file.seekp(0, ios::end);
    }
    return true;
  }

  auto open_wav(const string &filename) -> bool {
    if (filename != wav_filename) {
      if (file.is_open()) {
        file.close();
      }
    }
    if (!file.is_open()) {
      file.open(filename, ios::binary);
      wav_filename = filename;
      dataSize = 0;
    }
    return file.is_open();
  }

public:
  auto open(const string &filename, const uint32_t sample_rate,
            const uint16_t bits_per_sample, const uint16_t channels) -> bool {

    if (open_wav(filename)) {
      write_header(sample_rate, bits_per_sample, channels);
    } else {
      return false;
    }

    return true;
  }

  auto close() -> bool {
    file.close();
    return true;
  }

  auto write(const float *data, size_t length) -> bool {
    return write_audio(data, length);
  }

  ~wav_writer() {
    if (file.is_open()) {
      file.close();
    }
  }
};

// Apply a high-pass frequency filter to PCM audio
// Suppresses frequencies below cutoff Hz
void high_pass_filter(vector<float> &data, float cutoff, float sample_rate);

// Basic voice activity detection (VAD) using audio energy adaptive threshold
auto vad_simple(vector<float> &pcmf32, int sample_rate, int last_ms,
                float vad_thold, float freq_thold, bool verbose) -> bool;

// compute similarity between two strings using Levenshtein distance
auto similarity(const string &s0, const string &s1) -> float;

//
// Terminal utils
//

#define SQR(X) ((X) * (X))
#define UNCUBE(x) x < 48 ? 0 : x < 115 ? 1 : (x - 35) / 40

/**
 * Quantizes 24-bit RGB to xterm256 code range [16,256).
 */
static auto rgb2xterm256(int r, int g, int b) -> int {
  unsigned char cube[] = {0, 0137, 0207, 0257, 0327, 0377};
  int av, ir, ig, ib, il, qr, qg, qb, ql;
  av = r * .299 + g * .587 + b * .114 + .5;
  ql = (il = av > 238 ? 23 : (av - 3) / 10) * 10 + 8;
  qr = cube[(ir = UNCUBE(r))];
  qg = cube[(ig = UNCUBE(g))];
  qb = cube[(ib = UNCUBE(b))];
  if (SQR(qr - r) + SQR(qg - g) + SQR(qb - b) <=
      SQR(ql - r) + SQR(ql - g) + SQR(ql - b))
    return ir * 36 + ig * 6 + ib + 020;
  return il + 0350;
}

static auto set_xterm256_foreground(int r, int g, int b) -> string {
  int x = rgb2xterm256(r, g, b);
  ostringstream oss;
  oss << "\033[38;5;" << x << "m";
  return oss.str();
}

// Lowest is red, middle is yellow, highest is green. Color scheme from
// Paul Tol; it is colorblind friendly https://personal.sron.nl/~pault/
const vector<string> k_colors = {
    set_xterm256_foreground(220, 5, 12),
    set_xterm256_foreground(232, 96, 28),
    set_xterm256_foreground(241, 147, 45),
    set_xterm256_foreground(246, 193, 65),
    set_xterm256_foreground(247, 240, 86),
    set_xterm256_foreground(144, 201, 135),
    set_xterm256_foreground(78, 178, 101),
};

//
// Other utils
//

// check if file exists using ifstream
auto is_file_exist(const char *filename) -> bool;
